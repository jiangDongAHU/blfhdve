#include "kernel.cuh"
#include <opencv2/opencv.hpp>

using namespace cv;

//lower and upper bound of the reconstructed initial conditions
#define X_LOWER_BOUND -20
#define X_UPPER_BOUND  20
#define Y_LOWER_BOUND -20
#define Y_UPPER_BOUND  20
#define Z_LOWER_BOUND  10
#define Z_UPPER_BOUND  30
#define W_LOWER_BOUND -150
#define W_UPPER_BOUND  150

//parameters for Lorenz hyper-chaotic systems
#define SIGMA          10
#define RHO            28
#define BETA           8 / 3
#define GAMMA         -1
#define h              0.002

//semaphores used to wake up worker threads and to wait for worker threads to complete their respective tasks
sem_t wakeUpWorkerThreadsMutex[NUMBER_OF_WORKER_THREADS], waitForWorkerThreadsMutex[NUMBER_OF_WORKER_THREADS];

//the original frame is declared as a global variable to facilitate data sharing between the main thread and worker threads.
Mat originalFrame;

int main(){
    //open the original video file
    VideoCapture videoCapture;
    videoCapture.open(ORIGINAL_VIDEO_FILE_PATH);
    if(!videoCapture.isOpened()){
        printf("failed to open the original video file!\n");
        exit(-1);
    }

    //obtain the parameters of the original video
    int frameWidth         = (int)videoCapture.get(CAP_PROP_FRAME_WIDTH);
    int frameHeight        = (int)videoCapture.get(CAP_PROP_FRAME_HEIGHT);
    int videoFPS           = (int)videoCapture.get(CAP_PROP_FPS);
    int totalFrames        = (int)videoCapture.get(CAP_PROP_FRAME_COUNT);
    size_t frameDataLength = frameWidth * frameHeight * 3;

    //matrix used to store the results of the SHA256 hash calculations of the original frame by worker threads
    unsigned char SHA256HashResultMatrix[NUMBER_OF_WORKER_THREADS][SHA256_DIGEST_LENGTH];

    //array used to store the SHA256 hash of the original frame
    unsigned char SHA256HashResultArray[SHA256_DIGEST_LENGTH];

    //array used to store the initial conditions generated by the main thread to initialize the LHCSs of the worker threads
    double * initialConditionsArray           = (double *)malloc(NUMBER_OF_WORKER_THREADS * 8 * sizeof(double));

    //3: each frame consists of three channels 4: each iteration generates four iteration results
    int iterationsForGeneratingShiftDistances = (int)ceil((frameWidth + frameHeight) * 3 / (4 * NUMBER_OF_UINT16T_DATA_EXTRACTED_FROM_EACH_ITERATION_RESULT 
                                                           * NUMBER_OF_WORKER_THREADS));

    //sequence used to store the shift distance generated by the worker threads
    uint16_t * shiftDistanceSequence          = (uint16_t *)malloc(iterationsForGeneratingShiftDistances * 4 * NUMBER_OF_UINT16T_DATA_EXTRACTED_FROM_EACH_ITERATION_RESULT 
                                                                   * NUMBER_OF_WORKER_THREADS * sizeof(uint16_t));

    //3: each frame consists of three channels 4: each iteration generates four iteration results
    int iterationsForGeneratingByteSequence   = (int)ceil(frameWidth * frameHeight * 3 / (4 * NUMBER_OF_BYTES_EXTRACTED_FROM_EACH_ITERATION_RESULT * NUMBER_OF_WORKER_THREADS));
    
    //sequence used to the bytes generated by the worker threads
    unsigned char * byteSequence              = (unsigned char *)malloc(iterationsForGeneratingByteSequence * 4 * NUMBER_OF_BYTES_EXTRACTED_FROM_EACH_ITERATION_RESULT
                                                                        * NUMBER_OF_WORKER_THREADS * sizeof(unsigned char));

    //allocate memory on the GPU                                                                    
    uchar3 * deviceOriginalFrame           = NULL;
    uchar3 * deviceEncryptedFrame          = NULL;
    uchar3 * deviceEncryptedBitMatrix      = NULL;
    uchar3 * deviceTempBitMatrix           = NULL;
    uint16_t * deviceShiftDistanceSequence = NULL;
    unsigned char * deviceByteSequence     = NULL;

    cudaMalloc((void **) & deviceOriginalFrame,         frameDataLength);
    cudaMalloc((void **) & deviceEncryptedFrame,        frameDataLength);
    cudaMalloc((void **) & deviceEncryptedBitMatrix,    frameDataLength * 8);
    cudaMalloc((void **) & deviceTempBitMatrix,         frameDataLength * 8);
    cudaMalloc((void **) & deviceShiftDistanceSequence, iterationsForGeneratingShiftDistances * 4 * NUMBER_OF_UINT16T_DATA_EXTRACTED_FROM_EACH_ITERATION_RESULT 
                                                        * NUMBER_OF_WORKER_THREADS * sizeof(uint16_t));
    cudaMalloc((void **) & deviceByteSequence,          iterationsForGeneratingByteSequence   * 4 * NUMBER_OF_BYTES_EXTRACTED_FROM_EACH_ITERATION_RESULT
                                                        * NUMBER_OF_WORKER_THREADS * sizeof(unsigned char));
    
    //randomly select initial conditions to initialize the LHCSm
    srand((unsigned int)time(NULL));
    double x0 = generateRandomDoubleNumber(X_LOWER_BOUND, X_UPPER_BOUND);
    double y0 = generateRandomDoubleNumber(Y_LOWER_BOUND, Y_UPPER_BOUND);
    double z0 = generateRandomDoubleNumber(Z_LOWER_BOUND, Z_UPPER_BOUND);
    double w0 = generateRandomDoubleNumber(W_LOWER_BOUND, W_UPPER_BOUND);

    //initialize the semaphores
    for(int i = 0; i < NUMBER_OF_WORKER_THREADS; i++){
        sem_init(& wakeUpWorkerThreadsMutex[i],  0, 0);
        sem_init(& waitForWorkerThreadsMutex[i], 0, 0);
    }

    //create the worker threads
    struct workerThreadsParameterStructure wtps[NUMBER_OF_WORKER_THREADS];
    for(int i = 0; i < NUMBER_OF_WORKER_THREADS; i++){
        wtps[i].threadIndex                           = i;
        wtps[i].frameDataLengthForEachWorkerThread    = (frameWidth * frameHeight * 3) / NUMBER_OF_WORKER_THREADS;
        wtps[i].SHA256HashResultArray                 = SHA256HashResultMatrix[i];
        wtps[i].initialConditionArray                 = initialConditionsArray;
        wtps[i].iterationsForGeneratingShiftDistances = iterationsForGeneratingShiftDistances;
        wtps[i].shiftDistanceSequence                 = shiftDistanceSequence;
        wtps[i].iterationsForGeneratingByteSequence   = iterationsForGeneratingByteSequence;
        wtps[i].byteSequence                          = byteSequence;
    }

    pthread_t wtid[NUMBER_OF_WORKER_THREADS];
    for(int i = 0; i < NUMBER_OF_WORKER_THREADS; i++)
        pthread_create(& wtid[i], NULL, workerThreadFunction, (void *) & wtps[i]);

    double averageBlueChannelNPCR  = 0;
    double averageGreenChannelNPCR = 0;
    double averageRedChannelNPCR   = 0;

    double averageBlueChannelUACI  = 0;
    double averageGreenChannelUACI = 0;
    double averageRedChannelUACI   = 0;

    
    //Encrypt the original frame and subsequently decrypt the encrypted frame
    int frameIndex = 0;
    Mat encryptedFrame1(frameHeight, frameWidth, CV_8UC3, Scalar(0, 0, 0));
    Mat encryptedFrame2(frameHeight, frameWidth, CV_8UC3, Scalar(0, 0, 0));
    Mat differentialMap(frameHeight, frameWidth, CV_8UC1, Scalar(0));
    double totalTime = 0;
    double latencyCount = 0;

    while(videoCapture.read(originalFrame)){
        double startTime = getCPUSecond();

        //frame format validation
        int channels        = originalFrame.channels();
        int bitDepth        = originalFrame.depth();
        if(channels != 3 || bitDepth != 0 || frameDataLength % NUMBER_OF_WORKER_THREADS != 0 || frameWidth % GPU_BLOCK_LENGTH  != 0){
            printf("Frame format validation failed.\n");
            printf("The frame must have 3 channels and a bit depth of 8.\n");
            printf("The data length of the frame must be evenly divisible by the number of worker threads.\n");
            printf("The frame width must be evenly divisible by GPU_BLOCK_LENGTH.\n");
            exit(-1);
        } 

        //wake up all worker threads to calculate the SHA256 hashes for their respective sub-frames
        for(int i = 0; i < NUMBER_OF_WORKER_THREADS; i++)
            sem_post(& wakeUpWorkerThreadsMutex[i]);
        
        //wait all worker threads to complete the calculation
        for(int i = 0; i < NUMBER_OF_WORKER_THREADS; i++)
            sem_wait(& waitForWorkerThreadsMutex[i]);

        //calculate the SHA256 hash of the original frame
        for(int i = 0; i < SHA256_DIGEST_LENGTH; i++){
            unsigned char temp = 0;
            for(int j = 0; j < NUMBER_OF_WORKER_THREADS; j++){
                temp = temp ^ SHA256HashResultMatrix[j][i];
            }
            SHA256HashResultArray[i] = temp;
        }

        double x01, y01, z01, w01;
        if(frameIndex == 0){
            x01 = x0;
            y01 = y0;
            z01 = z0;
            w01 = w0;
        }

        //reconstruct the initial conditions using the SHA2-256 hash of the original frame
        x01 = reconstructInitialCondition(&SHA256HashResultArray[8 * 0], x01, X_LOWER_BOUND, X_UPPER_BOUND);
        y01 = reconstructInitialCondition(&SHA256HashResultArray[8 * 1], y01, Y_LOWER_BOUND, Y_UPPER_BOUND);
        z01 = reconstructInitialCondition(&SHA256HashResultArray[8 * 2], z01, Z_LOWER_BOUND, Z_UPPER_BOUND);
        w01 = reconstructInitialCondition(&SHA256HashResultArray[8 * 3], w01, W_LOWER_BOUND, W_UPPER_BOUND);

        //generate initial conditions to initialize the LHCSs of the worker threads
        generateInitialConditionsForWorkerThreads(&x01, &y01, &z01, &w01, initialConditionsArray);

        //wake up all worker threads to generate the shift distances and byte sequences
        for(int i = 0; i < NUMBER_OF_WORKER_THREADS; i++)
            sem_post(& wakeUpWorkerThreadsMutex[i]);

        //upload the original frame to the GPU
        cudaMemcpy(deviceOriginalFrame, originalFrame.data, frameDataLength, cudaMemcpyHostToDevice);
        
        //wait all worker threads to complete the generation
        for(int i = 0; i < NUMBER_OF_WORKER_THREADS; i++)
            sem_wait(& waitForWorkerThreadsMutex[i]);

        //upload the generated sequences to the GPU
        
        cudaMemcpy(deviceShiftDistanceSequence, shiftDistanceSequence, iterationsForGeneratingShiftDistances * 4 * NUMBER_OF_UINT16T_DATA_EXTRACTED_FROM_EACH_ITERATION_RESULT 
                                                                       * NUMBER_OF_WORKER_THREADS * sizeof(uint16_t), cudaMemcpyHostToDevice);
        cudaMemcpy(deviceByteSequence, byteSequence, iterationsForGeneratingByteSequence * 4 * NUMBER_OF_BYTES_EXTRACTED_FROM_EACH_ITERATION_RESULT
                                                     * NUMBER_OF_WORKER_THREADS * sizeof(unsigned char), cudaMemcpyHostToDevice);

        //encrypt the original frame
        encryptionKernelCaller(deviceOriginalFrame, deviceEncryptedFrame, deviceEncryptedBitMatrix, deviceTempBitMatrix,
                               deviceShiftDistanceSequence, deviceByteSequence, frameWidth, frameHeight, frameDataLength);

        //download the encrypted frame from the GPU
        cudaMemcpy(encryptedFrame1.data, deviceEncryptedFrame, frameDataLength, cudaMemcpyDeviceToHost);

        
        /*********************************************************************************************************************************************************************/
        //randomly select a channel and a pixel, modify the pixel by adding an randomly selected increment, and encrypt the resulting frame using the same key
        /*********************************************************************************************************************************************************************/

        int randY = rand() % frameHeight;
        int randX = rand() % frameWidth;
        int increment = rand() % 256;
        while(increment == 0)
            increment = rand() % 256;
        int randC = rand() % 3;

        //modify the original frame
        originalFrame.at<Vec3b>(randY, randX)[randC] = (originalFrame.at<Vec3b>(randY, randX)[randC] + increment) % 256;

        //wake up all worker threads to calculate the SHA256 hashes for their respective sub-frames
        for(int i = 0; i < NUMBER_OF_WORKER_THREADS; i++)
            sem_post(& wakeUpWorkerThreadsMutex[i]);
        
        //wait all worker threads to complete the calculation
        for(int i = 0; i < NUMBER_OF_WORKER_THREADS; i++)
            sem_wait(& waitForWorkerThreadsMutex[i]);

        //calculate the SHA256 hash of the original frame
        for(int i = 0; i < SHA256_DIGEST_LENGTH; i++){
            unsigned char temp = 0;
            for(int j = 0; j < NUMBER_OF_WORKER_THREADS; j++){
                temp = temp ^ SHA256HashResultMatrix[j][i];
            }
            SHA256HashResultArray[i] = temp;
        }

        double x02, y02, z02, w02;
        if(frameIndex == 0){
            x02 = x0;
            y02 = y0;
            z02 = z0;
            w02 = w0;
        }

        //reconstruct the initial conditions using the SHA2-256 hash of the original frame
        x02 = reconstructInitialCondition(&SHA256HashResultArray[8 * 0], x02, X_LOWER_BOUND, X_UPPER_BOUND);
        y02 = reconstructInitialCondition(&SHA256HashResultArray[8 * 1], y02, Y_LOWER_BOUND, Y_UPPER_BOUND);
        z02 = reconstructInitialCondition(&SHA256HashResultArray[8 * 2], z02, Z_LOWER_BOUND, Z_UPPER_BOUND);
        w02 = reconstructInitialCondition(&SHA256HashResultArray[8 * 3], w02, W_LOWER_BOUND, W_UPPER_BOUND);

        //generate initial conditions to initialize the LHCSs of the worker threads
        generateInitialConditionsForWorkerThreads(&x02, &y02, &z02, &w02, initialConditionsArray);

        //wake up all worker threads to generate the shift distances and byte sequences
        for(int i = 0; i < NUMBER_OF_WORKER_THREADS; i++)
            sem_post(& wakeUpWorkerThreadsMutex[i]);

        //upload the original frame to the GPU
        cudaMemcpy(deviceOriginalFrame, originalFrame.data, frameDataLength, cudaMemcpyHostToDevice);
        
        //wait all worker threads to complete the generation
        for(int i = 0; i < NUMBER_OF_WORKER_THREADS; i++)
            sem_wait(& waitForWorkerThreadsMutex[i]);

        //upload the generated sequences to the GPU       
        cudaMemcpy(deviceShiftDistanceSequence, shiftDistanceSequence, iterationsForGeneratingShiftDistances * 4 * NUMBER_OF_UINT16T_DATA_EXTRACTED_FROM_EACH_ITERATION_RESULT 
                                                                       * NUMBER_OF_WORKER_THREADS * sizeof(uint16_t), cudaMemcpyHostToDevice);
        cudaMemcpy(deviceByteSequence, byteSequence, iterationsForGeneratingByteSequence * 4 * NUMBER_OF_BYTES_EXTRACTED_FROM_EACH_ITERATION_RESULT
                                                     * NUMBER_OF_WORKER_THREADS * sizeof(unsigned char), cudaMemcpyHostToDevice);

        //encrypt the original frame
        encryptionKernelCaller(deviceOriginalFrame, deviceEncryptedFrame, deviceEncryptedBitMatrix, deviceTempBitMatrix,
                               deviceShiftDistanceSequence, deviceByteSequence, frameWidth, frameHeight, frameDataLength);

        //download the encrypted frame from the GPU
        cudaMemcpy(encryptedFrame2.data, deviceEncryptedFrame, frameDataLength, cudaMemcpyDeviceToHost);

        //calculate NPCR and UACI

        double blueChannelNPCRCounter  = 0;
        double greenChannelNPCRCounter = 0;
        double redChannelNPCRCounter   = 0;

        double blueChannelUACICounter  = 0;
        double greenChannelUACICounter = 0;
        double redChannelUACICounter   = 0;

        for(int i = 0; i < frameWidth; i++)
            for(int j = 0; j < frameHeight; j++){
                if(encryptedFrame1.at<Vec3b>(i, j)[0] != encryptedFrame2.at<Vec3b>(i, j)[0])
                    blueChannelNPCRCounter ++;

                if(encryptedFrame1.at<Vec3b>(i, j)[1] != encryptedFrame2.at<Vec3b>(i, j)[1])
                    greenChannelNPCRCounter ++;

                if(encryptedFrame1.at<Vec3b>(i, j)[2] != encryptedFrame2.at<Vec3b>(i, j)[2])
                    redChannelNPCRCounter ++;
                
                blueChannelUACICounter  = blueChannelUACICounter  + double(abs(encryptedFrame1.at<Vec3b>(i, j)[0] - encryptedFrame2.at<Vec3b>(i, j)[0])) / (frameWidth * frameHeight);
                greenChannelUACICounter = greenChannelUACICounter + double(abs(encryptedFrame1.at<Vec3b>(i, j)[1] - encryptedFrame2.at<Vec3b>(i, j)[1])) / (frameWidth * frameHeight);
                redChannelUACICounter   = redChannelUACICounter   + double(abs(encryptedFrame1.at<Vec3b>(i, j)[2] - encryptedFrame2.at<Vec3b>(i, j)[2])) / (frameWidth * frameHeight);      
        }

        double blueChannelNPCR  = blueChannelNPCRCounter  * 100 / (frameWidth * frameHeight);
        double greenChannelNPCR = greenChannelNPCRCounter * 100 / (frameWidth * frameHeight);
        double redChannelNPCR   = redChannelNPCRCounter   * 100 / (frameWidth * frameHeight);

        double blueChannelUACI  = blueChannelUACICounter  * 100 / 255;
        double greenChannelUACI = greenChannelUACICounter * 100 / 255;
        double redChannelUACI   = redChannelUACICounter   * 100 / 255;

        averageBlueChannelNPCR  += blueChannelNPCR;
        averageGreenChannelNPCR += greenChannelNPCR;
        averageRedChannelNPCR   += redChannelNPCR;

        averageBlueChannelUACI  += blueChannelUACI;
        averageGreenChannelUACI += greenChannelUACI;
        averageRedChannelUACI   += redChannelUACI;

        //process the differential map
        for(int i = 0; i < frameWidth; i++)
            for(int j = 0; j < frameHeight; j++){
                if(encryptedFrame1.at<Vec3b>(i, j)[0] == encryptedFrame2.at<Vec3b>(i, j)[0] ||
                   encryptedFrame1.at<Vec3b>(i, j)[1] == encryptedFrame2.at<Vec3b>(i, j)[1] ||
                   encryptedFrame1.at<Vec3b>(i, j)[2] == encryptedFrame2.at<Vec3b>(i, j)[2])

                   differentialMap.at<uchar>(i, j) = 255;

                else
                   differentialMap.at<uchar>(i, j) = 0;
        }


        double endTime = getCPUSecond(); 
        int waitKeyTime = (int)(1000 / videoFPS) - (int)((endTime - startTime) * 1000);
        if(waitKeyTime <= 0){
            waitKeyTime = 1;
        }
  
        if(frameIndex % 10 == 0){
            system("clear");
            printf("\033[1mreal-time bit-level encryption of full high definition video without diffusion\033[m\n");
            printf("frame width   : %-4d | frame height  : %-4d | FPS         : %-2d  | frames         :%-4d\n", frameWidth, frameHeight, videoFPS, totalFrames);
            printf("worker threads: %-2d   | 1000(ms) / FPS: %d   | frame index : %-3d | encryption time: --(ms)\n", NUMBER_OF_WORKER_THREADS, (int)(1000 / videoFPS), frameIndex);
            printf("delayed frames: --   | delay rate: --       | average encryption time            : --(ms)\n\n");
            printf("test results:\n");
            printf("selected channel: %d            | coordinate     : (%-3d, %-3d)   | increment      : %d\n", randC, randX, randY, increment);
            printf("NPCR(R)         : %f(%%) | NPCR(G)        : %f(%%) | NPCR(B)        : %f(%%)\n", redChannelNPCR, greenChannelNPCR, blueChannelNPCR);
            printf("UACI(R)         : %f(%%) | UACI(G)        : %f(%%) | UACI(B)        : %f(%%)\n", redChannelUACI, greenChannelUACI, blueChannelUACI);
            printf("average NPCR(R) : %f(%%) | average NPCR(G): %f(%%) | average NPCR(B): %f(%%)\n", averageRedChannelNPCR / (frameIndex + 1), averageGreenChannelNPCR / (frameIndex + 1), averageBlueChannelNPCR / (frameIndex + 1));
            printf("average UACI(R) : %f(%%) | average UACI(G): %f(%%) | average UACI(B): %f(%%)\n", averageRedChannelUACI / (frameIndex + 1), averageGreenChannelUACI / (frameIndex + 1), averageBlueChannelUACI / (frameIndex + 1));
        }
        frameIndex++;

        imshow("original frame",  originalFrame);
        imshow("encrypted frame 1", encryptedFrame1);
        imshow("encrypted frame 2", encryptedFrame2);
        imshow("differential map", differentialMap);
        waitKey(waitKeyTime);

    }    

    free(initialConditionsArray);
    free(shiftDistanceSequence);
    free(byteSequence);

    cudaFree(deviceOriginalFrame);
    cudaFree(deviceEncryptedFrame);
    cudaFree(deviceEncryptedBitMatrix);
    cudaFree(deviceTempBitMatrix);
    cudaFree(deviceShiftDistanceSequence);
    cudaFree(deviceByteSequence);

    //destroy the semaphores
    for(int i = 0; i < NUMBER_OF_WORKER_THREADS; i++){
        sem_destroy(& wakeUpWorkerThreadsMutex[i]);
        sem_destroy(& waitForWorkerThreadsMutex[i]);
    }

    //kill all worker threads
    for(int i = 0; i < NUMBER_OF_WORKER_THREADS; i++)
        pthread_cancel(wtid[i]);

    return 0;
}

static void * workerThreadFunction(void * arg){
    struct workerThreadsParameterStructure * wtps = (struct workerThreadsParameterStructure *) arg;
    int threadIndex                           =   wtps->threadIndex;
    int frameDataLengthForEachWorkerThread    =   wtps->frameDataLengthForEachWorkerThread;
    unsigned char * SHA256HashResultArray     =   wtps->SHA256HashResultArray;
    double * initialConditionArray            = & wtps->initialConditionArray[threadIndex * 8];
    int iterationsForGeneratingShiftDistances =   wtps->iterationsForGeneratingShiftDistances;
    uint16_t * shiftDistanceSequence          = & wtps->shiftDistanceSequence[threadIndex * iterationsForGeneratingShiftDistances * 4 
                                                                              * NUMBER_OF_UINT16T_DATA_EXTRACTED_FROM_EACH_ITERATION_RESULT];
    int iterationsForGeneratingByteSequence   =   wtps->iterationsForGeneratingByteSequence;
    unsigned char * byteSequence              = & wtps->byteSequence[threadIndex * iterationsForGeneratingByteSequence * 4
                                                                     * NUMBER_OF_BYTES_EXTRACTED_FROM_EACH_ITERATION_RESULT];

    //allocate memory for the worker thread
    double * iterationResultsArray1ForGeneratingShiftDistances = (double *)malloc(iterationsForGeneratingShiftDistances * 4 * sizeof(double));
    double * iterationResultsArray2ForGeneratingShiftDistances = (double *)malloc(iterationsForGeneratingShiftDistances * 4 * sizeof(double));

    uint16_t * generatedShiftDistances1                        = (uint16_t *)malloc(iterationsForGeneratingShiftDistances * 4 
                                                                                    * NUMBER_OF_UINT16T_DATA_EXTRACTED_FROM_EACH_ITERATION_RESULT * sizeof(uint16_t));  
    uint16_t * generatedShiftDistances2                        = (uint16_t *)malloc(iterationsForGeneratingShiftDistances * 4 
                                                                                    * NUMBER_OF_UINT16T_DATA_EXTRACTED_FROM_EACH_ITERATION_RESULT * sizeof(uint16_t)); 

    double * iterationResultsArray1ForGeneratingByteSequence   = (double *)malloc(iterationsForGeneratingByteSequence * 4 * sizeof(double)); 
    double * iterationResultsArray2ForGeneratingByteSequence   = (double *)malloc(iterationsForGeneratingByteSequence * 4 * sizeof(double));  

    unsigned char * generatedByteSequence1                     = (unsigned char *)malloc(iterationsForGeneratingByteSequence * 4
                                                                                         * NUMBER_OF_BYTES_EXTRACTED_FROM_EACH_ITERATION_RESULT * sizeof(unsigned char));
    unsigned char * generatedByteSequence2                     = (unsigned char *)malloc(iterationsForGeneratingByteSequence * 4
                                                                                         * NUMBER_OF_BYTES_EXTRACTED_FROM_EACH_ITERATION_RESULT * sizeof(unsigned char));    

    while(true){
        //wait to be awakened to calculate the SHA256 hash for the sub-frame
        sem_wait(& wakeUpWorkerThreadsMutex[threadIndex]);

        //calculate the SHA256 hash of the sub-frame assigned to this thread
        calculateSHA256Hash(& originalFrame.data[threadIndex * frameDataLengthForEachWorkerThread], frameDataLengthForEachWorkerThread, SHA256HashResultArray);

        //notify the main thread that the calculation is complete
        sem_post(& waitForWorkerThreadsMutex[threadIndex]);

        //wait to be awakened to generate the shift distances and byte sequence
        sem_wait(& wakeUpWorkerThreadsMutex[threadIndex]);

        //initialize the LHCSs using initial conditions generated by LHCSm
        int idx = 0;
        
        double x1 = initialConditionArray[idx ++];
        double y1 = initialConditionArray[idx ++];
        double z1 = initialConditionArray[idx ++];
        double w1 = initialConditionArray[idx ++];

        double x2 = initialConditionArray[idx ++];
        double y2 = initialConditionArray[idx ++];
        double z2 = initialConditionArray[idx ++];
        double w2 = initialConditionArray[idx ++];

        //pre-iterate the LHCSs
        for(int i = 0; i < PRE_ITERATIONS; i++){
            iterateLorenzHyperChaoticMap(&x1, &y1, &z1, &w1);
            iterateLorenzHyperChaoticMap(&x2, &y2, &z2, &w2);
        }

        //generate circular shift distance
        generateIterationResults(&x1, &y1, &z1, &w1, iterationsForGeneratingShiftDistances, iterationResultsArray1ForGeneratingShiftDistances);
        generateIterationResults(&x2, &y2, &z2, &w2, iterationsForGeneratingShiftDistances, iterationResultsArray2ForGeneratingShiftDistances);

        convertIterationResultsToUint16Data(iterationResultsArray1ForGeneratingShiftDistances, generatedShiftDistances1, iterationsForGeneratingShiftDistances * 4);
        convertIterationResultsToUint16Data(iterationResultsArray2ForGeneratingShiftDistances, generatedShiftDistances2, iterationsForGeneratingShiftDistances * 4);

        idx = 0;
        
        for(int i = 0; i < iterationsForGeneratingShiftDistances * 4 * NUMBER_OF_UINT16T_DATA_EXTRACTED_FROM_EACH_ITERATION_RESULT; i++)
            shiftDistanceSequence[idx ++] = generatedShiftDistances1[i] ^ generatedShiftDistances2[i];

        //generate byte sequence
        generateIterationResults(&x1, &y1, &z1, &w1, iterationsForGeneratingByteSequence, iterationResultsArray1ForGeneratingByteSequence);
        generateIterationResults(&x1, &y1, &z1, &w1, iterationsForGeneratingByteSequence, iterationResultsArray2ForGeneratingByteSequence);

        convertResultsToBytes(iterationResultsArray1ForGeneratingByteSequence, generatedByteSequence1, iterationsForGeneratingByteSequence * 4);
        convertResultsToBytes(iterationResultsArray2ForGeneratingByteSequence, generatedByteSequence2, iterationsForGeneratingByteSequence * 4);

        idx = 0; 
        
        for(int i = 0; i < iterationsForGeneratingByteSequence * 4 * NUMBER_OF_BYTES_EXTRACTED_FROM_EACH_ITERATION_RESULT; i++)
            byteSequence[idx ++] = generatedByteSequence1[i] ^ generatedByteSequence2[i];

        //notify the main thread that the generation is complete
        sem_post(& waitForWorkerThreadsMutex[threadIndex]);

        /*********************************************************************************************************************************************************************/
        //calculate the SHA-256 hash of the modified original frame，and use the regenerated inital conditions to produce shift distances and bytes
        /*********************************************************************************************************************************************************************/

        //wait to be awakened to calculate the SHA256 hash for the sub-frame
        sem_wait(& wakeUpWorkerThreadsMutex[threadIndex]);

        //calculate the SHA256 hash of the sub-frame assigned to this thread
        calculateSHA256Hash(& originalFrame.data[threadIndex * frameDataLengthForEachWorkerThread], frameDataLengthForEachWorkerThread, SHA256HashResultArray);

        //notify the main thread that the calculation is complete
        sem_post(& waitForWorkerThreadsMutex[threadIndex]);

        //wait to be awakened to generate the shift distances and byte sequence
        sem_wait(& wakeUpWorkerThreadsMutex[threadIndex]);

        //initialize the LHCSs using initial conditions generated by LHCSm
        idx = 0;
        
        x1 = initialConditionArray[idx ++];
        y1 = initialConditionArray[idx ++];
        z1 = initialConditionArray[idx ++];
        w1 = initialConditionArray[idx ++];

        x2 = initialConditionArray[idx ++];
        y2 = initialConditionArray[idx ++];
        z2 = initialConditionArray[idx ++];
        w2 = initialConditionArray[idx ++];

        //pre-iterate the LHCSs
        for(int i = 0; i < PRE_ITERATIONS; i++){
            iterateLorenzHyperChaoticMap(&x1, &y1, &z1, &w1);
            iterateLorenzHyperChaoticMap(&x2, &y2, &z2, &w2);
        }

        //generate circular shift distance
        generateIterationResults(&x1, &y1, &z1, &w1, iterationsForGeneratingShiftDistances, iterationResultsArray1ForGeneratingShiftDistances);
        generateIterationResults(&x2, &y2, &z2, &w2, iterationsForGeneratingShiftDistances, iterationResultsArray2ForGeneratingShiftDistances);

        convertIterationResultsToUint16Data(iterationResultsArray1ForGeneratingShiftDistances, generatedShiftDistances1, iterationsForGeneratingShiftDistances * 4);
        convertIterationResultsToUint16Data(iterationResultsArray2ForGeneratingShiftDistances, generatedShiftDistances2, iterationsForGeneratingShiftDistances * 4);

        idx = 0;
        
        for(int i = 0; i < iterationsForGeneratingShiftDistances * 4 * NUMBER_OF_UINT16T_DATA_EXTRACTED_FROM_EACH_ITERATION_RESULT; i++)
            shiftDistanceSequence[idx ++] = generatedShiftDistances1[i] ^ generatedShiftDistances2[i];

        //generate byte sequence
        generateIterationResults(&x1, &y1, &z1, &w1, iterationsForGeneratingByteSequence, iterationResultsArray1ForGeneratingByteSequence);
        generateIterationResults(&x1, &y1, &z1, &w1, iterationsForGeneratingByteSequence, iterationResultsArray2ForGeneratingByteSequence);

        convertResultsToBytes(iterationResultsArray1ForGeneratingByteSequence, generatedByteSequence1, iterationsForGeneratingByteSequence * 4);
        convertResultsToBytes(iterationResultsArray2ForGeneratingByteSequence, generatedByteSequence2, iterationsForGeneratingByteSequence * 4);

        idx = 0; 
        
        for(int i = 0; i < iterationsForGeneratingByteSequence * 4 * NUMBER_OF_BYTES_EXTRACTED_FROM_EACH_ITERATION_RESULT; i++)
            byteSequence[idx ++] = generatedByteSequence1[i] ^ generatedByteSequence2[i];

        //notify the main thread that the generation is complete
        sem_post(& waitForWorkerThreadsMutex[threadIndex]);
    }

    free(iterationResultsArray1ForGeneratingShiftDistances);
    free(iterationResultsArray2ForGeneratingShiftDistances);
    free(generatedShiftDistances1);
    free(generatedShiftDistances2);
    free(iterationResultsArray1ForGeneratingByteSequence);
    free(iterationResultsArray2ForGeneratingByteSequence);
    free(generatedByteSequence1);
    free(generatedByteSequence2);

    return NULL;
}

//generate a double-precision floating-point number within the range of minValue and maxValue
double generateRandomDoubleNumber(double minValue, double maxValue){
    double randomNumber = (double)rand() / (double)RAND_MAX;

    return minValue + randomNumber * (maxValue - minValue);
}

//get cpu time
double getCPUSecond(void){
    struct timeval tp;
    gettimeofday(&tp, NULL);
    return((double)tp.tv_sec + (double)tp.tv_usec * 1.e-6);
}

//calculate SHA256 hash
void calculateSHA256Hash(unsigned char * frameData, size_t dataLength, unsigned char * SHA256HashResultArray){
    //SHA256 structure
    SHA256_CTX sha256;

    //initialize the structure
    SHA256_Init(& sha256);

    //update the structure with the frame data
    SHA256_Update(& sha256, frameData, dataLength);

    //finalize the hash and store the result
    SHA256_Final(SHA256HashResultArray, & sha256);
}

//reconstruct the initial condition using the generated SHA2-256 hash
double reconstructInitialCondition(unsigned char * SHA256HashResultArray, double initialCondition, int16_t lowerBound, int16_t upperBound){
    uint64_t uint64InitialCondition;
    memcpy(&uint64InitialCondition, &initialCondition, sizeof(uint64_t));

    //construct the integer part
    unsigned char ucharIntegerPartArray[2];
    for(int i = 0;i < 2; i++){
        memcpy(&ucharIntegerPartArray[i], &uint64InitialCondition, 1);
        uint64InitialCondition = uint64InitialCondition >> 8;
    }

    uint16_t integerPart = 0;
    integerPart = ucharIntegerPartArray[0] ^ * SHA256HashResultArray ++;
    integerPart = integerPart << 8;
    integerPart = (integerPart | ucharIntegerPartArray[1]) ^ * SHA256HashResultArray ++;

    int16_t range         = upperBound - lowerBound + 1;
    int16_t integerResult = ((int16_t)integerPart % range + range) % range + lowerBound;

    //construct the decimal part
    double decimalPart = initialCondition - floor(initialCondition);
    uint64_t uint64DecimalPart;
    memcpy(&uint64DecimalPart, &decimalPart, sizeof(uint64_t));
    unsigned char ucharDecimalPartArray[8];
    for(int i = 0; i < 8; i++){
        memcpy(&ucharDecimalPartArray[i], &uint64DecimalPart, 1);
        uint64DecimalPart = uint64DecimalPart >> 8;
    }

    for(int i = 0; i < 6; i++){
        ucharDecimalPartArray[i] = ucharDecimalPartArray[i] ^ * SHA256HashResultArray++;
    }

    //construct the result
    uint64_t uint64Result = 0;
    for(int i = 7; i >= 0; i--){
        uint64Result = uint64Result | ucharDecimalPartArray[i];

        if(i != 0)
            uint64Result = uint64Result << 8;
    } 

    double result;
    memcpy(&result, &uint64Result, sizeof(double));
    result = result + (double)integerResult;

    return result;
}

//generate initial conditions for initializing LHCSs of the worker threads
void generateInitialConditionsForWorkerThreads(double * x0, double * y0, double * z0, double * w0, double * initialConditionArray){
    //pre-iterate the LHCSm
    for(int i = 0; i < PRE_ITERATIONS; i++)
        iterateLorenzHyperChaoticMap(x0, y0, z0, w0);

    int idx = 0;
    for(int i = 0; i < NUMBER_OF_WORKER_THREADS; i++){
        iterateLorenzHyperChaoticMap(x0, y0, z0, w0);
        initialConditionArray[idx ++] = * x0;
        initialConditionArray[idx ++] = * y0;
        initialConditionArray[idx ++] = * z0;
        initialConditionArray[idx ++] = * w0;

        iterateLorenzHyperChaoticMap(x0, y0, z0, w0);
        initialConditionArray[idx ++] = * x0;
        initialConditionArray[idx ++] = * y0;
        initialConditionArray[idx ++] = * z0;
        initialConditionArray[idx ++] = * w0;
    }
}

//iterate Lorenz map and return the results
void iterateLorenzHyperChaoticMap(double * x, double * y, double * z, double * w){
    
    double K11 = SIGMA * ((* y) - (* x)) + (* w);
    double K12 = SIGMA * ((* y) - ((* x) + (h / 2) * K11)) + (* w);
    double K13 = SIGMA * ((* y) - ((* x) + (h / 2) * K12)) + (* w);
    double K14 = SIGMA * ((* y) - ((* x) + h * K13)) + (* w);
    * x = (* x) + (h / 6) * (K11 + 2 * K12 + 2 * K13 + K14);

    double K21 = RHO * (* x) - (* y) - (* x) * (* z);
    double K22 = RHO * (* x) - ((* y) + (h / 2) * K21) - (* x) * (* z); 
    double K23 = RHO * (* x) - ((* y) + (h / 2) * K22) - (* x) * (* z); 
    double K24 = RHO * (* x) - ((* y) + h * K23) - (* x) * (* z);
    * y = (* y) + (h / 6) * (K21 + 2 * K22 + 2 * K23 + K24);

    double K31 = (* x) * (* y) - BETA * (* z);
    double K32 = (* x) * (* y) - BETA * ((* z) + (h / 2) * K31);
    double K33 = (* x) * (* y) - BETA * ((* z) + (h / 2) * K32);
    double K34 = (* x) * (* y) - BETA * ((* z) + h * K33);
    * z = (* z) + (h / 6) * (K31 + 2 * K32 + 2 * K33 + K34);

    double K41 = GAMMA * (* w) - ((* y) * (* z));
    double K42 = GAMMA * (* w + (h / 2) * K41) - ((* y) * (* z));
    double K43 = GAMMA * (* w + (h / 2) * K42) - ((* y) * (* z));
    double K44 = GAMMA * (* w + h * K43) - ((* y) * (* z));
    * w = (* w) + (h / 6) * (K41 + 2 * K42 + 2 * K43 + K44);
}

//iterate the hyper chaotic map, generate iteration results, and store the results
void generateIterationResults(double * x, double * y, double * z, double * w, int iterations, double * iterationResultArray){
    
    int idx = 0;

    for(int i = 0; i < iterations; i++){
        iterateLorenzHyperChaoticMap(x, y, z, w);

        iterationResultArray[idx++] = * x;
        iterationResultArray[idx++] = * y;
        iterationResultArray[idx++] = * z;
        iterationResultArray[idx++] = * w;
    }
}

//convert iteration results into uint16_t data
void convertIterationResultsToUint16Data(double * iterationResultArray, uint16_t * uint16ResultArray, int numberOfIterationsResults){

    for(int i = 0; i < numberOfIterationsResults; i ++){
        uint16_t * p = & uint16ResultArray[i * NUMBER_OF_UINT16T_DATA_EXTRACTED_FROM_EACH_ITERATION_RESULT];
        memcpy(p, & iterationResultArray[i], sizeof(uint16_t) * NUMBER_OF_UINT16T_DATA_EXTRACTED_FROM_EACH_ITERATION_RESULT);
    }
}

//convert iteration results into bytes
void convertResultsToBytes(double * iterationResultArray, unsigned char * byteSequence, int numberOfIterationsResults){  

    for(int i = 0; i < numberOfIterationsResults; i++){
        unsigned char * p = & byteSequence[i * NUMBER_OF_BYTES_EXTRACTED_FROM_EACH_ITERATION_RESULT];
        memcpy(p, & iterationResultArray[i], NUMBER_OF_BYTES_EXTRACTED_FROM_EACH_ITERATION_RESULT);
    }
}
