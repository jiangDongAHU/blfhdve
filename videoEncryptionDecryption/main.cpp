#include "kernel.cuh"
#include <opencv2/opencv.hpp>

using namespace cv;

//lower and upper bound of the reconstructed initial conditions
#define X_LOWER_BOUND -20
#define X_UPPER_BOUND  20
#define Y_LOWER_BOUND -20
#define Y_UPPER_BOUND  20
#define Z_LOWER_BOUND  10
#define Z_UPPER_BOUND  30
#define W_LOWER_BOUND -150
#define W_UPPER_BOUND  150

//parameters for Lorenz hyper-chaotic systems
#define SIGMA          10
#define RHO            28
#define BETA           8 / 3
#define GAMMA         -1
#define h              0.002

//semaphores used to wake up worker threads and to wait for worker threads to complete their respective tasks
sem_t wakeUpWorkerThreadsMutex[NUMBER_OF_WORKER_THREADS], waitForWorkerThreadsMutex[NUMBER_OF_WORKER_THREADS];

//the original frame is declared as a global variable to facilitate data sharing between the main thread and worker threads.
Mat originalFrame;

int main(){
    //open the original video file
    VideoCapture videoCapture;
    videoCapture.open(ORIGINAL_VIDEO_FILE_PATH);
    if(!videoCapture.isOpened()){
        printf("failed to open the original video file!\n");
        exit(-1);
    }

    //obtain the parameters of the original video
    int frameWidth         = (int)videoCapture.get(CAP_PROP_FRAME_WIDTH);
    int frameHeight        = (int)videoCapture.get(CAP_PROP_FRAME_HEIGHT);
    int videoFPS           = (int)videoCapture.get(CAP_PROP_FPS);
    int totalFrames        = (int)videoCapture.get(CAP_PROP_FRAME_COUNT);
    size_t frameDataLength = frameWidth * frameHeight * 3;

    //matrix used to store the results of the SHA256 hash calculations of the original frame by worker threads
    unsigned char SHA256HashResultMatrix[NUMBER_OF_WORKER_THREADS][SHA256_DIGEST_LENGTH];

    //array used to store the SHA256 hash of the original frame
    unsigned char SHA256HashResultArray[SHA256_DIGEST_LENGTH];

    //array used to store the initial conditions generated by the main thread to initialize the LHCSs of the worker threads
    double * initialConditionsArray           = (double *)malloc(NUMBER_OF_WORKER_THREADS * 8 * sizeof(double));

    //3: each frame consists of three channels 4: each iteration generates four iteration results
    int iterationsForGeneratingShiftDistances = (int)ceil((frameWidth + frameHeight) * 3 / (4 * NUMBER_OF_UINT16T_DATA_EXTRACTED_FROM_EACH_ITERATION_RESULT 
                                                           * NUMBER_OF_WORKER_THREADS));

    //sequence used to store the shift distance generated by the worker threads
    uint16_t * shiftDistanceSequence          = (uint16_t *)malloc(iterationsForGeneratingShiftDistances * 4 * NUMBER_OF_UINT16T_DATA_EXTRACTED_FROM_EACH_ITERATION_RESULT 
                                                                   * NUMBER_OF_WORKER_THREADS * sizeof(uint16_t));

    //3: each frame consists of three channels 4: each iteration generates four iteration results
    int iterationsForGeneratingByteSequence   = (int)ceil(frameWidth * frameHeight * 3 / (4 * NUMBER_OF_BYTES_EXTRACTED_FROM_EACH_ITERATION_RESULT * NUMBER_OF_WORKER_THREADS));
    
    //sequence used to the bytes generated by the worker threads
    unsigned char * byteSequence              = (unsigned char *)malloc(iterationsForGeneratingByteSequence * 4 * NUMBER_OF_BYTES_EXTRACTED_FROM_EACH_ITERATION_RESULT
                                                                        * NUMBER_OF_WORKER_THREADS * sizeof(unsigned char));

    //allocate memory on the GPU                                                                    
    uchar3 * deviceOriginalFrame           = NULL;
    uchar3 * deviceEncryptedFrame          = NULL;
    uchar3 * deviceDecryptedFrame          = NULL;
    uchar3 * deviceEncryptedBitMatrix      = NULL;
    uchar3 * deviceTempBitMatrix           = NULL;
    uchar3 * deviceDecryptedBitMatrix      = NULL;
    uint16_t * deviceShiftDistanceSequence = NULL;
    unsigned char * deviceByteSequence     = NULL;

    cudaMalloc((void **) & deviceOriginalFrame,         frameDataLength);
    cudaMalloc((void **) & deviceEncryptedFrame,        frameDataLength);
    cudaMalloc((void **) & deviceDecryptedFrame,        frameDataLength);
    cudaMalloc((void **) & deviceEncryptedBitMatrix,    frameDataLength * 8);
    cudaMalloc((void **) & deviceTempBitMatrix,         frameDataLength * 8);
    cudaMalloc((void **) & deviceDecryptedBitMatrix,    frameDataLength * 8);
    cudaMalloc((void **) & deviceShiftDistanceSequence, iterationsForGeneratingShiftDistances * 4 * NUMBER_OF_UINT16T_DATA_EXTRACTED_FROM_EACH_ITERATION_RESULT 
                                                        * NUMBER_OF_WORKER_THREADS * sizeof(uint16_t));
    cudaMalloc((void **) & deviceByteSequence,          iterationsForGeneratingByteSequence   * 4 * NUMBER_OF_BYTES_EXTRACTED_FROM_EACH_ITERATION_RESULT
                                                        * NUMBER_OF_WORKER_THREADS * sizeof(unsigned char));
    
    //randomly select initial conditions to initialize the LHCSm
    srand((unsigned int)time(NULL));
    double x0 = generateRandomDoubleNumber(X_LOWER_BOUND, X_UPPER_BOUND);
    double y0 = generateRandomDoubleNumber(Y_LOWER_BOUND, Y_UPPER_BOUND);
    double z0 = generateRandomDoubleNumber(Z_LOWER_BOUND, Z_UPPER_BOUND);
    double w0 = generateRandomDoubleNumber(W_LOWER_BOUND, W_UPPER_BOUND);

    //initialize the semaphores
    for(int i = 0; i < NUMBER_OF_WORKER_THREADS; i++){
        sem_init(& wakeUpWorkerThreadsMutex[i],  0, 0);
        sem_init(& waitForWorkerThreadsMutex[i], 0, 0);
    }

    //create the worker threads
    struct workerThreadsParameterStructure wtps[NUMBER_OF_WORKER_THREADS];
    for(int i = 0; i < NUMBER_OF_WORKER_THREADS; i++){
        wtps[i].threadIndex                           = i;
        wtps[i].frameDataLengthForEachWorkerThread    = (frameWidth * frameHeight * 3) / NUMBER_OF_WORKER_THREADS;
        wtps[i].SHA256HashResultArray                 = SHA256HashResultMatrix[i];
        wtps[i].initialConditionArray                 = initialConditionsArray;
        wtps[i].iterationsForGeneratingShiftDistances = iterationsForGeneratingShiftDistances;
        wtps[i].shiftDistanceSequence                 = shiftDistanceSequence;
        wtps[i].iterationsForGeneratingByteSequence   = iterationsForGeneratingByteSequence;
        wtps[i].byteSequence                          = byteSequence;
    }

    pthread_t wtid[NUMBER_OF_WORKER_THREADS];
    for(int i = 0; i < NUMBER_OF_WORKER_THREADS; i++)
        pthread_create(& wtid[i], NULL, workerThreadFunction, (void *) & wtps[i]);
    
    //Encrypt the original frame and subsequently decrypt the encrypted frame
    int frameIndex = 0;
    Mat encryptedFrame(frameHeight, frameWidth, CV_8UC3, Scalar(0, 0, 0));
    Mat decryptedFrame(frameHeight, frameWidth, CV_8UC3, Scalar(0, 0, 0));
    double totalTime = 0;
    double latencyCount = 0;

    while(videoCapture.read(originalFrame)){
        double startTime = getCPUSecond();

        //frame format validation
        int channels        = originalFrame.channels();
        int bitDepth        = originalFrame.depth();
        if(channels != 3 || bitDepth != 0 || frameDataLength % NUMBER_OF_WORKER_THREADS != 0 || frameWidth % GPU_BLOCK_LENGTH  != 0){
            printf("Frame format validation failed.\n");
            printf("The frame must have 3 channels and a bit depth of 8.\n");
            printf("The data length of the frame must be evenly divisible by the number of worker threads.\n");
            printf("The frame width must be evenly divisible by GPU_BLOCK_LENGTH.\n");
            exit(-1);
        } 

        //wake up all worker threads to calculate the SHA256 hashes for their respective sub-frames
        for(int i = 0; i < NUMBER_OF_WORKER_THREADS; i++)
            sem_post(& wakeUpWorkerThreadsMutex[i]);
        
        //wait all worker threads to complete the calculation
        for(int i = 0; i < NUMBER_OF_WORKER_THREADS; i++)
            sem_wait(& waitForWorkerThreadsMutex[i]);

        //calculate the SHA256 hash of the original frame
        for(int i = 0; i < SHA256_DIGEST_LENGTH; i++){
            unsigned char temp = 0;
            for(int j = 0; j < NUMBER_OF_WORKER_THREADS; j++){
                temp = temp ^ SHA256HashResultMatrix[j][i];
            }
            SHA256HashResultArray[i] = temp;
        }

        //reconstruct the initial conditions using the SHA2-256 hash of the original frame
        x0 = reconstructInitialCondition(&SHA256HashResultArray[8 * 0], x0, X_LOWER_BOUND, X_UPPER_BOUND);
        y0 = reconstructInitialCondition(&SHA256HashResultArray[8 * 1], y0, Y_LOWER_BOUND, Y_UPPER_BOUND);
        z0 = reconstructInitialCondition(&SHA256HashResultArray[8 * 2], z0, Z_LOWER_BOUND, Z_UPPER_BOUND);
        w0 = reconstructInitialCondition(&SHA256HashResultArray[8 * 3], w0, W_LOWER_BOUND, W_UPPER_BOUND);

        //generate initial conditions to initialize the LHCSs of the worker threads
        generateInitialConditionsForWorkerThreads(&x0, &y0, &z0, &w0, initialConditionsArray);

        //wake up all worker threads to generate the shift distances and byte sequences
        for(int i = 0; i < NUMBER_OF_WORKER_THREADS; i++)
            sem_post(& wakeUpWorkerThreadsMutex[i]);

        //upload the original frame to the GPU
        cudaMemcpy(deviceOriginalFrame, originalFrame.data, frameDataLength, cudaMemcpyHostToDevice);
        
        //wait all worker threads to complete the generation
        for(int i = 0; i < NUMBER_OF_WORKER_THREADS; i++)
            sem_wait(& waitForWorkerThreadsMutex[i]);

        //upload the generated sequences to the GPU
        
        cudaMemcpy(deviceShiftDistanceSequence, shiftDistanceSequence, iterationsForGeneratingShiftDistances * 4 * NUMBER_OF_UINT16T_DATA_EXTRACTED_FROM_EACH_ITERATION_RESULT 
                                                                       * NUMBER_OF_WORKER_THREADS * sizeof(uint16_t), cudaMemcpyHostToDevice);
        cudaMemcpy(deviceByteSequence, byteSequence, iterationsForGeneratingByteSequence * 4 * NUMBER_OF_BYTES_EXTRACTED_FROM_EACH_ITERATION_RESULT
                                                     * NUMBER_OF_WORKER_THREADS * sizeof(unsigned char), cudaMemcpyHostToDevice);

        //encrypt the original frame
        encryptionKernelCaller(deviceOriginalFrame, deviceEncryptedFrame, deviceEncryptedBitMatrix, deviceTempBitMatrix,
                               deviceShiftDistanceSequence, deviceByteSequence, frameWidth, frameHeight, frameDataLength);

        //download the encrypted frame from the GPU
        cudaMemcpy(encryptedFrame.data, deviceEncryptedFrame, frameDataLength, cudaMemcpyDeviceToHost);

        double encryptionTime = getCPUSecond();
        totalTime             = totalTime + (encryptionTime - startTime) * 1000;
        if((encryptionTime - startTime) * 1000 > (int)(1000 / videoFPS))
            latencyCount ++;

        //decrypt the encrypted frame
        decryptionKernelCaller(deviceEncryptedFrame, deviceDecryptedFrame, deviceDecryptedBitMatrix, deviceTempBitMatrix,
                               deviceShiftDistanceSequence, deviceByteSequence, frameWidth, frameHeight, frameDataLength);

        //download the decrypted frame from the GPU
        cudaMemcpy(decryptedFrame.data, deviceDecryptedFrame, frameDataLength, cudaMemcpyDeviceToHost);
        
        double endTime = getCPUSecond();
        int waitKeyTime = (int)(1000 / videoFPS) - (int)((endTime - startTime) * 1000);
        if(waitKeyTime <= 0){
            waitKeyTime = 1;
        }
        

        if(frameIndex % 10 == 0){
            system("clear");
            printf("\033[1mreal-time bit-level encryption of full high definition video without diffusion\033[m\n");
            printf("frame width   : %-4d | frame height  : %-4d | FPS         : %-2d  | frames         :%-4d\n", frameWidth, frameHeight, videoFPS, totalFrames);
            printf("worker threads: %-2d   | 1000(ms) / FPS: %d   | frame index : %-3d | encryption time: %.2f(ms)\n", NUMBER_OF_WORKER_THREADS, (int)(1000 / videoFPS), frameIndex, (encryptionTime - startTime) * 1000);
            printf("delayed frames: %.0f    | delay rate: %.2f     | average encryption time            : %.2f (ms)\n", latencyCount, latencyCount / (frameIndex + 1), totalTime / (frameIndex + 1));
        }
        frameIndex++;

        imshow("encrypted frame", encryptedFrame);
        imshow("decrypted frame", decryptedFrame);
        waitKey(waitKeyTime);

    }    

    free(initialConditionsArray);
    free(shiftDistanceSequence);
    free(byteSequence);

    cudaFree(deviceOriginalFrame);
    cudaFree(deviceEncryptedFrame);
    cudaFree(deviceDecryptedFrame);
    cudaFree(deviceEncryptedBitMatrix);
    cudaFree(deviceTempBitMatrix);
    cudaFree(deviceDecryptedBitMatrix);
    cudaFree(deviceShiftDistanceSequence);
    cudaFree(deviceByteSequence);

    //destroy the semaphores
    for(int i = 0; i < NUMBER_OF_WORKER_THREADS; i++){
        sem_destroy(& wakeUpWorkerThreadsMutex[i]);
        sem_destroy(& waitForWorkerThreadsMutex[i]);
    }

    //kill all worker threads
    for(int i = 0; i < NUMBER_OF_WORKER_THREADS; i++)
        pthread_cancel(wtid[i]);

    return 0;
}

static void * workerThreadFunction(void * arg){
    struct workerThreadsParameterStructure * wtps = (struct workerThreadsParameterStructure *) arg;
    int threadIndex                           =   wtps->threadIndex;
    int frameDataLengthForEachWorkerThread    =   wtps->frameDataLengthForEachWorkerThread;
    unsigned char * SHA256HashResultArray     =   wtps->SHA256HashResultArray;
    double * initialConditionArray            = & wtps->initialConditionArray[threadIndex * 8];
    int iterationsForGeneratingShiftDistances =   wtps->iterationsForGeneratingShiftDistances;
    uint16_t * shiftDistanceSequence          = & wtps->shiftDistanceSequence[threadIndex * iterationsForGeneratingShiftDistances * 4 
                                                                              * NUMBER_OF_UINT16T_DATA_EXTRACTED_FROM_EACH_ITERATION_RESULT];
    int iterationsForGeneratingByteSequence   =   wtps->iterationsForGeneratingByteSequence;
    unsigned char * byteSequence              = & wtps->byteSequence[threadIndex * iterationsForGeneratingByteSequence * 4
                                                                     * NUMBER_OF_BYTES_EXTRACTED_FROM_EACH_ITERATION_RESULT];

    //allocate memory for the worker thread
    double * iterationResultsArray1ForGeneratingShiftDistances = (double *)malloc(iterationsForGeneratingShiftDistances * 4 * sizeof(double));
    double * iterationResultsArray2ForGeneratingShiftDistances = (double *)malloc(iterationsForGeneratingShiftDistances * 4 * sizeof(double));

    uint16_t * generatedShiftDistances1                        = (uint16_t *)malloc(iterationsForGeneratingShiftDistances * 4 
                                                                                    * NUMBER_OF_UINT16T_DATA_EXTRACTED_FROM_EACH_ITERATION_RESULT * sizeof(uint16_t));  
    uint16_t * generatedShiftDistances2                        = (uint16_t *)malloc(iterationsForGeneratingShiftDistances * 4 
                                                                                    * NUMBER_OF_UINT16T_DATA_EXTRACTED_FROM_EACH_ITERATION_RESULT * sizeof(uint16_t)); 

    double * iterationResultsArray1ForGeneratingByteSequence   = (double *)malloc(iterationsForGeneratingByteSequence * 4 * sizeof(double)); 
    double * iterationResultsArray2ForGeneratingByteSequence   = (double *)malloc(iterationsForGeneratingByteSequence * 4 * sizeof(double));  

    unsigned char * generatedByteSequence1                     = (unsigned char *)malloc(iterationsForGeneratingByteSequence * 4
                                                                                         * NUMBER_OF_BYTES_EXTRACTED_FROM_EACH_ITERATION_RESULT * sizeof(unsigned char));
    unsigned char * generatedByteSequence2                     = (unsigned char *)malloc(iterationsForGeneratingByteSequence * 4
                                                                                         * NUMBER_OF_BYTES_EXTRACTED_FROM_EACH_ITERATION_RESULT * sizeof(unsigned char));    

    while(true){
        //wait to be awakened to calculate the SHA256 hash for the sub-frame
        sem_wait(& wakeUpWorkerThreadsMutex[threadIndex]);

        //calculate the SHA256 hash of the sub-frame assigned to this thread
        calculateSHA256Hash(& originalFrame.data[threadIndex * frameDataLengthForEachWorkerThread], frameDataLengthForEachWorkerThread, SHA256HashResultArray);

        //notify the main thread that the calculation is complete
        sem_post(& waitForWorkerThreadsMutex[threadIndex]);

        //wait to be awakened to generate the shift distances and byte sequence
        sem_wait(& wakeUpWorkerThreadsMutex[threadIndex]);

        //initialize the LHCSs using initial conditions generated by LHCSm
        int idx = 0;
        
        double x1 = initialConditionArray[idx ++];
        double y1 = initialConditionArray[idx ++];
        double z1 = initialConditionArray[idx ++];
        double w1 = initialConditionArray[idx ++];

        double x2 = initialConditionArray[idx ++];
        double y2 = initialConditionArray[idx ++];
        double z2 = initialConditionArray[idx ++];
        double w2 = initialConditionArray[idx ++];

        //pre-iterate the LHCSs
        for(int i = 0; i < PRE_ITERATIONS; i++){
            iterateLorenzHyperChaoticMap(&x1, &y1, &z1, &w1);
            iterateLorenzHyperChaoticMap(&x2, &y2, &z2, &w2);
        }

        //generate circular shift distance
        generateIterationResults(&x1, &y1, &z1, &w1, iterationsForGeneratingShiftDistances, iterationResultsArray1ForGeneratingShiftDistances);
        generateIterationResults(&x2, &y2, &z2, &w2, iterationsForGeneratingShiftDistances, iterationResultsArray2ForGeneratingShiftDistances);

        convertIterationResultsToUint16Data(iterationResultsArray1ForGeneratingShiftDistances, generatedShiftDistances1, iterationsForGeneratingShiftDistances * 4);
        convertIterationResultsToUint16Data(iterationResultsArray2ForGeneratingShiftDistances, generatedShiftDistances2, iterationsForGeneratingShiftDistances * 4);

        idx = 0;
        
        for(int i = 0; i < iterationsForGeneratingShiftDistances * 4 * NUMBER_OF_UINT16T_DATA_EXTRACTED_FROM_EACH_ITERATION_RESULT; i++)
            shiftDistanceSequence[idx ++] = generatedShiftDistances1[i] ^ generatedShiftDistances2[i];

        //generate byte sequence
        generateIterationResults(&x1, &y1, &z1, &w1, iterationsForGeneratingByteSequence, iterationResultsArray1ForGeneratingByteSequence);
        generateIterationResults(&x1, &y1, &z1, &w1, iterationsForGeneratingByteSequence, iterationResultsArray2ForGeneratingByteSequence);

        convertResultsToBytes(iterationResultsArray1ForGeneratingByteSequence, generatedByteSequence1, iterationsForGeneratingByteSequence * 4);
        convertResultsToBytes(iterationResultsArray2ForGeneratingByteSequence, generatedByteSequence2, iterationsForGeneratingByteSequence * 4);

        idx = 0; 
        
        for(int i = 0; i < iterationsForGeneratingByteSequence * 4 * NUMBER_OF_BYTES_EXTRACTED_FROM_EACH_ITERATION_RESULT; i++)
            byteSequence[idx ++] = generatedByteSequence1[i] ^ generatedByteSequence2[i];

        //notify the main thread that the generation is complete
        sem_post(& waitForWorkerThreadsMutex[threadIndex]);

    }

    free(iterationResultsArray1ForGeneratingShiftDistances);
    free(iterationResultsArray2ForGeneratingShiftDistances);
    free(generatedShiftDistances1);
    free(generatedShiftDistances2);
    free(iterationResultsArray1ForGeneratingByteSequence);
    free(iterationResultsArray2ForGeneratingByteSequence);
    free(generatedByteSequence1);
    free(generatedByteSequence2);

    return NULL;
}

//generate a double-precision floating-point number within the range of minValue and maxValue
double generateRandomDoubleNumber(double minValue, double maxValue){
    double randomNumber = (double)rand() / (double)RAND_MAX;

    return minValue + randomNumber * (maxValue - minValue);
}

//get cpu time
double getCPUSecond(void){
    struct timeval tp;
    gettimeofday(&tp, NULL);
    return((double)tp.tv_sec + (double)tp.tv_usec * 1.e-6);
}

//calculate SHA256 hash
void calculateSHA256Hash(unsigned char * frameData, size_t dataLength, unsigned char * SHA256HashResultArray){
    //SHA256 structure
    SHA256_CTX sha256;

    //initialize the structure
    SHA256_Init(& sha256);

    //update the structure with the frame data
    SHA256_Update(& sha256, frameData, dataLength);

    //finalize the hash and store the result
    SHA256_Final(SHA256HashResultArray, & sha256);
}

//reconstruct the initial condition using the generated SHA2-256 hash
double reconstructInitialCondition(unsigned char * SHA256HashResultArray, double initialCondition, int16_t lowerBound, int16_t upperBound){
    uint64_t uint64InitialCondition;
    memcpy(&uint64InitialCondition, &initialCondition, sizeof(uint64_t));

    //construct the integer part
    unsigned char ucharIntegerPartArray[2];
    for(int i = 0;i < 2; i++){
        memcpy(&ucharIntegerPartArray[i], &uint64InitialCondition, 1);
        uint64InitialCondition = uint64InitialCondition >> 8;
    }

    uint16_t integerPart = 0;
    integerPart = ucharIntegerPartArray[0] ^ * SHA256HashResultArray ++;
    integerPart = integerPart << 8;
    integerPart = (integerPart | ucharIntegerPartArray[1]) ^ * SHA256HashResultArray ++;

    int16_t range         = upperBound - lowerBound + 1;
    int16_t integerResult = ((int16_t)integerPart % range + range) % range + lowerBound;

    //construct the decimal part
    double decimalPart = initialCondition - floor(initialCondition);
    uint64_t uint64DecimalPart;
    memcpy(&uint64DecimalPart, &decimalPart, sizeof(uint64_t));
    unsigned char ucharDecimalPartArray[8];
    for(int i = 0; i < 8; i++){
        memcpy(&ucharDecimalPartArray[i], &uint64DecimalPart, 1);
        uint64DecimalPart = uint64DecimalPart >> 8;
    }

    for(int i = 0; i < 6; i++){
        ucharDecimalPartArray[i] = ucharDecimalPartArray[i] ^ * SHA256HashResultArray++;
    }

    //construct the result
    uint64_t uint64Result = 0;
    for(int i = 7; i >= 0; i--){
        uint64Result = uint64Result | ucharDecimalPartArray[i];

        if(i != 0)
            uint64Result = uint64Result << 8;
    } 

    double result;
    memcpy(&result, &uint64Result, sizeof(double));
    result = result + (double)integerResult;

    return result;
}

//generate initial conditions for initializing LHCSs of the worker threads
void generateInitialConditionsForWorkerThreads(double * x0, double * y0, double * z0, double * w0, double * initialConditionArray){
    //pre-iterate the LHCSm
    for(int i = 0; i < PRE_ITERATIONS; i++)
        iterateLorenzHyperChaoticMap(x0, y0, z0, w0);

    int idx = 0;
    for(int i = 0; i < NUMBER_OF_WORKER_THREADS; i++){
        iterateLorenzHyperChaoticMap(x0, y0, z0, w0);
        initialConditionArray[idx ++] = * x0;
        initialConditionArray[idx ++] = * y0;
        initialConditionArray[idx ++] = * z0;
        initialConditionArray[idx ++] = * w0;

        iterateLorenzHyperChaoticMap(x0, y0, z0, w0);
        initialConditionArray[idx ++] = * x0;
        initialConditionArray[idx ++] = * y0;
        initialConditionArray[idx ++] = * z0;
        initialConditionArray[idx ++] = * w0;
    }
}

//iterate Lorenz map and return the results
void iterateLorenzHyperChaoticMap(double * x, double * y, double * z, double * w){
    
    double K11 = SIGMA * ((* y) - (* x)) + (* w);
    double K12 = SIGMA * ((* y) - ((* x) + (h / 2) * K11)) + (* w);
    double K13 = SIGMA * ((* y) - ((* x) + (h / 2) * K12)) + (* w);
    double K14 = SIGMA * ((* y) - ((* x) + h * K13)) + (* w);
    * x = (* x) + (h / 6) * (K11 + 2 * K12 + 2 * K13 + K14);

    double K21 = RHO * (* x) - (* y) - (* x) * (* z);
    double K22 = RHO * (* x) - ((* y) + (h / 2) * K21) - (* x) * (* z); 
    double K23 = RHO * (* x) - ((* y) + (h / 2) * K22) - (* x) * (* z); 
    double K24 = RHO * (* x) - ((* y) + h * K23) - (* x) * (* z);
    * y = (* y) + (h / 6) * (K21 + 2 * K22 + 2 * K23 + K24);

    double K31 = (* x) * (* y) - BETA * (* z);
    double K32 = (* x) * (* y) - BETA * ((* z) + (h / 2) * K31);
    double K33 = (* x) * (* y) - BETA * ((* z) + (h / 2) * K32);
    double K34 = (* x) * (* y) - BETA * ((* z) + h * K33);
    * z = (* z) + (h / 6) * (K31 + 2 * K32 + 2 * K33 + K34);

    double K41 = GAMMA * (* w) - ((* y) * (* z));
    double K42 = GAMMA * (* w + (h / 2) * K41) - ((* y) * (* z));
    double K43 = GAMMA * (* w + (h / 2) * K42) - ((* y) * (* z));
    double K44 = GAMMA * (* w + h * K43) - ((* y) * (* z));
    * w = (* w) + (h / 6) * (K41 + 2 * K42 + 2 * K43 + K44);
}

//iterate the hyper chaotic map, generate iteration results, and store the results
void generateIterationResults(double * x, double * y, double * z, double * w, int iterations, double * iterationResultArray){
    
    int idx = 0;

    for(int i = 0; i < iterations; i++){
        iterateLorenzHyperChaoticMap(x, y, z, w);

        iterationResultArray[idx++] = * x;
        iterationResultArray[idx++] = * y;
        iterationResultArray[idx++] = * z;
        iterationResultArray[idx++] = * w;
    }
}

//convert iteration results into uint16_t data
void convertIterationResultsToUint16Data(double * iterationResultArray, uint16_t * uint16ResultArray, int numberOfIterationsResults){

    for(int i = 0; i < numberOfIterationsResults; i ++){
        uint16_t * p = & uint16ResultArray[i * NUMBER_OF_UINT16T_DATA_EXTRACTED_FROM_EACH_ITERATION_RESULT];
        memcpy(p, & iterationResultArray[i], sizeof(uint16_t) * NUMBER_OF_UINT16T_DATA_EXTRACTED_FROM_EACH_ITERATION_RESULT);
    }
}

//convert iteration results into bytes
void convertResultsToBytes(double * iterationResultArray, unsigned char * byteSequence, int numberOfIterationsResults){  

    for(int i = 0; i < numberOfIterationsResults; i++){
        unsigned char * p = & byteSequence[i * NUMBER_OF_BYTES_EXTRACTED_FROM_EACH_ITERATION_RESULT];
        memcpy(p, & iterationResultArray[i], NUMBER_OF_BYTES_EXTRACTED_FROM_EACH_ITERATION_RESULT);
    }
}
